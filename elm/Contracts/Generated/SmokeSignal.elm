module Contracts.Generated.SmokeSignal exposing
    ( HashBurn
    , HashTip
    , MessageBurn
    , StoredMessageData
    , burnHash
    , burnMessage
    , donationAddress
    , hashBurnDecoder
    , hashBurnEvent
    , hashTipDecoder
    , hashTipEvent
    , messageBurnDecoder
    , messageBurnEvent
    , storedMessageData
    , storedMessageDataDecoder
    , tipHashOrBurnIfNoAuthor
    , token
    )

import BigInt exposing (BigInt)
import Eth.Abi.Decode as D exposing (abiDecode, andMap, data, toElmDecoder, topic)
import Eth.Abi.Encode as E exposing (Encoding(..), abiEncode)
import Eth.Types exposing (..)
import Eth.Utils as U
import Json.Decode as Decode exposing (Decoder, succeed)
import Json.Decode.Pipeline exposing (custom)



{-

   This file was generated by https://github.com/cmditch/elm-ethereum-generator v4.0.0
   Compatible with elm-ethereum v4.0.0

-}
-- burnHash(bytes32,uint256,uint256) function


burnHash : Address -> Hex -> BigInt -> BigInt -> Call ()
burnHash contractAddress hash_ burnAmount_ donateAmount_ =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| E.functionCall "0d5fac77" [ E.staticBytes 32 hash_, E.uint burnAmount_, E.uint donateAmount_ ]
    , nonce = Nothing
    , decoder = Decode.succeed ()
    }



-- burnMessage(string,uint256,uint256) function


burnMessage : Address -> String -> BigInt -> BigInt -> Call Hex
burnMessage contractAddress message_ burnAmount_ donateAmount_ =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| E.functionCall "1028553d" [ E.string message_, E.uint burnAmount_, E.uint donateAmount_ ]
    , nonce = Nothing
    , decoder = toElmDecoder (D.staticBytes 32)
    }



-- donationAddress() function


donationAddress : Address -> Call Address
donationAddress contractAddress =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| E.functionCall "ec034bed" []
    , nonce = Nothing
    , decoder = toElmDecoder D.address
    }



-- storedMessageData(bytes32) function


type alias StoredMessageData =
    { firstAuthor : Address
    , totalBurned : BigInt
    , totalTipped : BigInt
    }


storedMessageData : Address -> Hex -> Call StoredMessageData
storedMessageData contractAddress a_ =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| E.functionCall "056a2dd6" [ E.staticBytes 32 a_ ]
    , nonce = Nothing
    , decoder = storedMessageDataDecoder
    }


storedMessageDataDecoder : Decoder StoredMessageData
storedMessageDataDecoder =
    abiDecode StoredMessageData
        |> andMap D.address
        |> andMap D.uint
        |> andMap D.uint
        |> toElmDecoder



-- tipHashOrBurnIfNoAuthor(bytes32,uint256,uint256) function


tipHashOrBurnIfNoAuthor : Address -> Hex -> BigInt -> BigInt -> Call ()
tipHashOrBurnIfNoAuthor contractAddress hash_ amount_ donateAmount_ =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| E.functionCall "dbd9deba" [ E.staticBytes 32 hash_, E.uint amount_, E.uint donateAmount_ ]
    , nonce = Nothing
    , decoder = Decode.succeed ()
    }



-- token() function


token : Address -> Call Address
token contractAddress =
    { to = Just contractAddress
    , from = Nothing
    , gas = Nothing
    , gasPrice = Nothing
    , value = Nothing
    , data = Just <| E.functionCall "fc0c546a" []
    , nonce = Nothing
    , decoder = toElmDecoder D.address
    }



-- HashBurn(bytes32,address,uint256) event


type alias HashBurn =
    { hash : Hex
    , from : Address
    , burnAmount : BigInt
    }


hashBurnEvent : Address -> Maybe Hex -> Maybe Address -> LogFilter
hashBurnEvent contractAddress hash_ from_ =
    { fromBlock = LatestBlock
    , toBlock = LatestBlock
    , address = contractAddress
    , topics =
        [ Just <| U.unsafeToHex "343b147c051e2ac50523eb3bbd7bda256fe20f64f8c4c1c7e6f7b9b8c162755d"
        , Maybe.map (abiEncode << E.staticBytes 32) hash_
        , Maybe.map (abiEncode << E.address) from_
        ]
    }


hashBurnDecoder : Decoder HashBurn
hashBurnDecoder =
    Decode.succeed HashBurn
        |> custom (topic 1 (D.staticBytes 32))
        |> custom (topic 2 D.address)
        |> custom (data 0 D.uint)



-- HashTip(bytes32,address,uint256) event


type alias HashTip =
    { hash : Hex
    , from : Address
    , tipAmount : BigInt
    }


hashTipEvent : Address -> Maybe Hex -> Maybe Address -> LogFilter
hashTipEvent contractAddress hash_ from_ =
    { fromBlock = LatestBlock
    , toBlock = LatestBlock
    , address = contractAddress
    , topics =
        [ Just <| U.unsafeToHex "910c02b7cc5590261f1f076989f1570151cd8401f2f9db863cc260c170576c4f"
        , Maybe.map (abiEncode << E.staticBytes 32) hash_
        , Maybe.map (abiEncode << E.address) from_
        ]
    }


hashTipDecoder : Decoder HashTip
hashTipDecoder =
    Decode.succeed HashTip
        |> custom (topic 1 (D.staticBytes 32))
        |> custom (topic 2 D.address)
        |> custom (data 0 D.uint)



-- MessageBurn(bytes32,address,uint256,string) event


type alias MessageBurn =
    { hash : Hex
    , from : Address
    , burnAmount : BigInt
    , message : String
    }


messageBurnEvent : Address -> Maybe Hex -> Maybe Address -> LogFilter
messageBurnEvent contractAddress hash_ from_ =
    { fromBlock = LatestBlock
    , toBlock = LatestBlock
    , address = contractAddress
    , topics =
        [ Just <| U.unsafeToHex "555288072588ecd9d95a72f03f4bf18f419c7edad2c7a56d3f0c56ec313857fe"
        , Maybe.map (abiEncode << E.staticBytes 32) hash_
        , Maybe.map (abiEncode << E.address) from_
        ]
    }


messageBurnDecoder : Decoder MessageBurn
messageBurnDecoder =
    Decode.succeed MessageBurn
        |> custom (topic 1 (D.staticBytes 32))
        |> custom (topic 2 D.address)
        |> custom (data 0 D.uint)
        |> custom (data 1 D.string)
